# 镜子🪞

### 0.效果展示

Gif：

<img src="https://cdn.jsdelivr.net/gh/shuaigougou5545/blog-image/img/202308251559289.gif" alt="屏幕录制2023-08-25 15.57.16_0002" style="zoom:100%;" />

### 1.工程介绍

该工程用于实现**镜子**效果，用于练习**深度测试、模版测试、混合**这三种高级OpenGL渲染，t类似于d3d12龙书的经典案例，以OpenGL形式实现

场景介绍：场景中有一面镜子，镜子面前有一个Box，我们希望正确的渲染出镜子里的虚像；渲染实体：场景中1个Box，镜子，以及镜子中反射的Box虚像

### 2.分析

VBO、EBO：共用就行，镜子用压扁的box代替

VAO、light-uniform：共用就行

纹理：可用可不用吧，用shader输出颜色好了

shader：能否共用？待考量，透明镜子是否需要额外写一个shader，或者配uniform参数值即可

深度测试、模版测试、混合等状态需要切换

渲染流程：先渲染box，再渲染镜子的模版缓冲，再渲染box虚像，最后渲染透明镜子

‼️镜中物的渲染：

- 如何描述对称，且是否会影响绕序？
  - 我们是绕着一个平面对称的，所以对物体进行整体的旋转是一个错误的方法，会让物体上下颠倒，我们应该是对每个点进行对称计算，得到最终的结果
  - 虽然对称不能被拆成SRT，但是可以构造一个**对称矩阵**，对xyz进行处理，所以依旧可以用model矩阵来表示物体的总变换
- 光源也得对称过去

### 3.推理

#### （1）渲染过程

渲染过程的状态设置略，反正要注意状态设置需要闭合，不能让上一帧影响下一帧～

#### （2）对称矩阵

我们根据一个平面进行对称，一般描述平面有以下几种方式：
$$
n\cdot(p-p_0)=0
\\ n\cdot p+d=0
\\ ax+by+cz+d=0
$$
假设点A、B关于平面M对称，那么过A作垂线(方向：平面法线)找到平面上的点M，A、B关于M对称：
$$
M=p_1+k\cdot n
\\ n\cdot(M-p_0)=0
\\ \therefore k=\frac{-d-p_1\cdot n}{n\cdot n}
\\ \therefore p_2=p_1+2kn=p_1+2\frac{-d-p_1\cdot n}{n\cdot n}n
\\ =>假设n是单位向量
\\ \therefore p_2=p_1+ 2n\cdot(p_0-p_1)
\\p_2=(I-2n)\cdot p_1+2n\cdot P_0
$$
🤔️查看结论，我们可以得到一个更简单的推导：不管p0在平面的哪个位置，n·(p0-p1)就是(p0-p1)在n方向的投影向量！

所以投影矩阵(列为主序)：
$$
M = \begin{bmatrix}
 (I-2n).x & 0 & 0 & 2n\cdot p_0\\
 0 & (I-2n).y & 0 & 2n\cdot p_0\\
 0 & 0 & (I-2n).z & 2n\cdot p_0\\
 0 & 0 & 0 & 1
\end{bmatrix}
$$
或者写成SRT的形式：

```cpp
S = glm::vec3(glm::vec3(1.0) - 2 * n);
T = glm::vec3(2 * glm::dot(n, p0));
```

### 4.⚠️注意事项

在一次渲染循环中，状态设置函数的使用得是闭合的，也就是如果一次循环的结尾，假如说关闭了深度测试，或者关闭了颜色写入，而没有重新恢复原样，那么就会影响下一次循环
